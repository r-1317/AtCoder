# AHC057

## 00提出
- 提出前順位: /
- 提出日時: 
- 絶対スコア: 
- 順位: /

## 最初の方針
- ユークリッド距離
- 上位の解法ではほぼ1点に集まる感じかな
- 結合によって動きが変わるから面倒
- 結合を290回行う必要がある
- とりあえず時刻0で近場の点と結合するプログラムを作成しよう

## 01の方針
- 時刻0で近場の点と結合する

## 01提出
- 提出前順位: 321/342
- 提出日時: 2025-11-29 16:01:50
- 絶対スコア: 403024208
- 順位: 203/346

## 01を踏まえて
- 最初はこんなもん
- 大きさが2以上の集合を合成する方法は計算が大変そう
- logの計算が間違っているのかもしれないけれど、上位でもこれの1/4のコストはかかっているのかな
- 3クロックごとに1つ結合するとか
- それの貪欲

## 02の方針
- 基本は01
- 3クロックごとに1つ結合する
- 最も距離が近いものを貪欲に
- 時刻867で終わるかな
- 巨大な集合が11個できるとかもあるのか
- 大きさが11以上の集合は10個までに制限しよう
- やはりうまくいかんね
- 大きさが2以上の集合を制限した

## 02提出
- 提出前順位: 429/558
- 提出日時: 2025-11-29 17:31:24
- TLE
- そういえば10秒以上かかるんだった
- C++に変換しよう

## 02提出(2回目, C++)
- 提出前順位: 442/572
- 提出日時: 2025-11-29 17:42:15
- 絶対スコア: 2025-11-29 17:42:15
- 順位: 284/573

## 02を踏まえて(2回目)
- なかなか良いのでは
- 今日は参加者が少ないから順位がよく見えるだけかも
- この先どうするか
- 距離が2000(くらいの定数)以下ならすべて結合?

## 03の方針
- 基本は02
- 距離が定数以下なら無条件に取り込む
- 中心を予め決めてしまうか
  - それはやめた
- どうもうまく行かない
- それに、そこまで強くなさそう
- 今更だけど、集合が大きくなるほど速度は平均化されて遅くなるのでは